__external enum fxstr : uint32_t; // Magic to use the adjacent .fxstr file to resolve hashes.

struct DATADESCv1 __transparent {
  uint32_t default_technique;
  uint32_t unknown[3];
  uint32_t num_techniques;
  struct {
    uint32_t num_textures;
    struct {
      __label("slot %u: %s[%u]", vs_slot, hash, dimension);
      fxstr hash;
      uint32_t unknown = 1;
      uint32_t vs_slot;
      uint32_t gs_slot = vs_slot;
      uint32_t ps_slot = vs_slot;
      uint32_t hs_slot = vs_slot;
      uint32_t ds_slot = vs_slot;
      uint32_t cs_slot = vs_slot;
      uint8_t dimension;
    } textures[num_textures];
  } _extention[];
};

enum DataType : uint32_t {
  int = 0,
  float = 1,
  float2 = 3,
  float3 = 4,
  float4 = 5,
  float4x3 = 7,
  float4x4 = 8,
  texture = 9,
};

struct ParmElement7 {
  __label("%s %s[%u]", data_type, hash, array_size);
  fxstr hash;
  DataType data_type;
  uint32_t array_size;
  uint32_t unknown1;
  uint32_t unknown2;
};

struct ParmElement8 {
  __label("%s %s[%u]", data_type, hash, array_size);
  fxstr hash;
  DataType data_type;
  uint32_t array_size;
  uint32_t byte_offset;
  uint32_t unknown1;
  uint32_t unknown2;
};

struct DATAPARMv1 __transparent {
  // The version of this chunk is always v1, but the format depends on whether
  // the adjacent DATATECH is v7 or v8. As the definition language doesn't have
  // sibling constraints, the following hack differentiates between the two.
  uint32_t _dummy[5];
  uint32_t _discriminant;
  __byte_offset(&_dummy, 0);
  switch(_discriminant) {
  case  0: ParmElement8 _elements[];
  case  1: ParmElement8 _elements[];
  default: ParmElement7 _elements[];
  }
};

struct UInt32 {
  __label("%u", _value);
  uint32_t _value;
};

struct TechniquePassTexture {
  __label("%s", hash);
  fxstr hash;
  uint32_t flags; // Either 0 or 2. Is always 0 in DATATECHv8.
  uint32_t _vs_slot = 65535;
  uint32_t _gs_slot = 65535;
  uint32_t ps_slot;
  uint32_t _hs_slot = 65535;
  uint32_t _ds_slot = 65535;
  uint32_t _cs_slot = 65535;
  uint8_t _unknown = 1;
};

struct TechniqueProperty {
  __label("%s", hash);
  fxstr hash;
  uint32_t data_type;
  uint32_t _value_len;
  uint8_t value[_value_len];
};

struct DATATECHv7 __transparent {
  struct {
    uint32_t _discriminant;
    __byte_offset(&_discriminant, 0);
    switch(_discriminant) {
    case 0:
    default:
      __label("#%d: %s (%s)", _t, hash, second_hash);
      fxstr hash;
      fxstr second_hash;
      uint32_t _list1_len;
      uint32_t _list2_len;
      uint32_t _list3_len;
      uint32_t unknown1;
      uint32_t unknown2 = 0;
      uint32_t unknown3;
      uint32_t unknown4 = 0;
      uint32_t _list4_len;
      uint32_t unknown5;
      uint32_t unknown6 = 0;
      uint32_t _num_passes;
      uint32_t _prop_count;
      UInt32 list1[_list1_len]; // Possibly a list of parameter indicies.
      UInt32 list2[_list2_len]; // Almost certainly not a list of parameter indicies.
      UInt32 list3[_list3_len]; // Possibly a list of parameter indicies.
      UInt32 list4[_list4_len]; // Possibly a list of parameter indicies.
      struct {
        __label("#%d", _p);
        uint32_t unknown = 24;
        uint32_t _child_count;
        uint8_t unknown[444];
        TechniquePassTexture textures[_child_count];
      } passes[_num_passes as _p];
      TechniqueProperty props[_prop_count];
    }
  } techniques[as _t]; // The length of this array is given by DATADESCv1.num_techniques, but as that cannot be specified, the _discriminant hack is used to detect techniques_aux[0].zero.
  struct {
    __label("#%d", _t);
    uint32_t zero = 0;
  } techniques_aux[as _t];
};

struct TechniqueID {
  int16_t technique_id;
  uint16_t _padding = 0;
};

struct SkeletalVariants {
  TechniqueID without_skeleton;
  TechniqueID with_skeleton;
};

struct Unknown4Variants {
  SkeletalVariants without_unknown4;
  SkeletalVariants with_unknown4;
};

struct TexCoord9Variants {
  Unknown4Variants without_texcoord9;
  Unknown4Variants with_texcoord9;
};

struct DATATECHv8 __transparent {
  struct {
    __label("#%d: %s (%s [%d,%d])", _t, hash, second_hash, uses_texcoord9, uses_skeleton);
    fxstr hash;
    fxstr second_hash;
    uint32_t _unknown1 = 1;
    uint32_t _unknown2 = 0;
    uint32_t  uses_skeleton; // 1 if the associated vertex shaders use BLENDINDICES and BLENDWEIGHT, 0 if they do not
    uint32_t _unknown4 = 0;
    uint32_t  uses_texcoord9; // 1 if the associated vertex shaders use TEXCOORD9, 0 if they do not
    uint32_t _unknown6 = 8;
    uint32_t _num_passes;
    uint32_t _prop_count;
    TexCoord9Variants technique_variants;
    struct {
      __label("#%d", _p);
      uint32_t unknown = 24;
      uint32_t _child_count;
      uint8_t unknown[444];
      TechniquePassTexture textures[_child_count];
    } passes[_num_passes as _p];
    TechniqueProperty props[_prop_count];
  } techniques[as _t];
};